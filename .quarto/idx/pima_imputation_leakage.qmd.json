{"title":"Pima Imputation → Leak vs Leak-free (R)","markdown":{"yaml":{"title":"Pima Imputation → Leak vs Leak-free (R)","format":{"html":{"toc":true,"code-fold":true}},"execute":{"echo":true,"warning":false,"message":false}},"headingText":"Imputation leakage with insulin (no scaling)","containsRefs":false,"markdown":"\n\n```{r}\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(tidymodels)\n\ntheme_set(theme_minimal())\nset.seed(123)\n```\n\n\nFollowing the scaling concept, if we are learning anything from the data, this should  strictly happen in the training data. Therefore, when imputing we have to be aware of data leakage too. As an example, we now look at **mean imputation of `insulin`**:\n\n- **Outcome**: `pedigree`\n- **Predictors**: `age`, `insulin_imp`\n- We compare:\n  - ❌ **WRONG**: mean for imputation computed using **all data** (leakage)\n  - ✅ **RIGHT**: mean for imputation computed using **training data only**\n  \n\n```{r}\ndata(\"PimaIndiansDiabetes2\", package = \"mlbench\")\n\npima_imp <- PimaIndiansDiabetes2 %>%\n  clean_names() %>%\n  select(age, insulin, pedigree) %>%\n  filter(!is.na(pedigree))  # outcome must be present\n\nsummary(pima_imp)\n```\n\n### 1. WRONG pipeline: impute using global mean (leakage)\n\nHere we:\n\n1. Compute the **global mean insulin** using all rows.\n2. Impute missing insulin values with this global mean.\n3. Then split into train/test.\n4. Fit `pedigree ~ age + insulin_imp` and evaluate MAE.\n\n```{r}\n# 1. Global mean (leaky: uses all data)\nmean_all_insulin <- mean(pima_imp$insulin, na.rm = TRUE)\nmean_all_insulin\n```\n\n```{r}\n# 2. Impute WHOLE dataset with global mean (before splitting)\npima_imp_wrong <- pima_imp %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_all_insulin, insulin)\n  )\n\nsummary(pima_imp_wrong$insulin_imp)\n```\n\n```{r}\n# 3. Train–test split AFTER imputation (still leaky)\nset.seed(123)\nsplit_wrong <- initial_split(pima_imp_wrong, prop = 0.7)\n\ntrain_wrong <- training(split_wrong)\ntest_wrong  <- testing(split_wrong)\n\nnrow(train_wrong); nrow(test_wrong)\n```\n\n```{r}\n# 4. Fit linear regression and compute MAE (WRONG)\nped_model <- linear_reg() %>%\n  set_engine(\"lm\")\n\nfit_wrong_imp <- ped_model %>%\n  fit(pedigree ~ age + insulin_imp, data = train_wrong)\n\ntidy(fit_wrong_imp)\n```\n\n```{r}\nresults_wrong_imp <- predict(fit_wrong_imp, new_data = test_wrong) %>%\n  bind_cols(test_wrong)\n\nmae_wrong_imp <- mae(\n  data     = results_wrong_imp,\n  truth    = pedigree,\n  estimate = .pred\n)\n\nmae_wrong_imp\n```\n\n---\n\n### 2. RIGHT pipeline: impute using training mean only (no leakage)\n\nNow we:\n\n1. Split the **original (unimputed)** data into train/test.\n2. Compute mean insulin **using training data only**.\n3. Impute train and test using this **training mean**.\n4. Fit the same model and compute MAE.\n\n```{r}\n# 1. Train–test split on RAW data\nset.seed(123)\nsplit_right <- initial_split(pima_imp, prop = 0.7)\n\ntrain_right <- training(split_right)\ntest_right  <- testing(split_right)\n\nnrow(train_right); nrow(test_right)\n```\n\n```{r}\n# 2. Training-only mean for insulin (correct)\nmean_tr_insulin <- mean(train_right$insulin, na.rm = TRUE)\nmean_tr_insulin\n```\n\n```{r}\n# 3. Impute train and test using TRAIN mean\ntrain_right_imp <- train_right %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_tr_insulin, insulin)\n  )\n\ntest_right_imp <- test_right %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_tr_insulin, insulin)\n  )\n\nsummary(train_right_imp$insulin_imp)\nsummary(test_right_imp$insulin_imp)\n```\n\n```{r}\n# 4. Fit linear regression and compute MAE (RIGHT)\nfit_right_imp <- ped_model %>%\n  fit(pedigree ~ age + insulin_imp, data = train_right_imp)\n\ntidy(fit_right_imp)\n```\n\n```{r}\nresults_right_imp <- predict(fit_right_imp, new_data = test_right_imp) %>%\n  bind_cols(test_right_imp)\n\nmae_right_imp <- mae(\n  data     = results_right_imp,\n  truth    = pedigree,\n  estimate = .pred\n)\n\nmae_right_imp\n```\n\n---\n\n### 3. Compare MAE: imputation with vs without leakage\n\n```{r}\ntibble(\n  pipeline = c(\"WRONG: impute with global mean (leakage)\",\n               \"RIGHT: impute with training mean only\"),\n  MAE = c(mae_wrong_imp$.estimate,\n          mae_right_imp$.estimate)\n)\n```\n\n","srcMarkdownNoYaml":"\n\n```{r}\nlibrary(tidyverse)\nlibrary(janitor)\nlibrary(tidymodels)\n\ntheme_set(theme_minimal())\nset.seed(123)\n```\n\n## Imputation leakage with insulin (no scaling)\n\nFollowing the scaling concept, if we are learning anything from the data, this should  strictly happen in the training data. Therefore, when imputing we have to be aware of data leakage too. As an example, we now look at **mean imputation of `insulin`**:\n\n- **Outcome**: `pedigree`\n- **Predictors**: `age`, `insulin_imp`\n- We compare:\n  - ❌ **WRONG**: mean for imputation computed using **all data** (leakage)\n  - ✅ **RIGHT**: mean for imputation computed using **training data only**\n  \n\n```{r}\ndata(\"PimaIndiansDiabetes2\", package = \"mlbench\")\n\npima_imp <- PimaIndiansDiabetes2 %>%\n  clean_names() %>%\n  select(age, insulin, pedigree) %>%\n  filter(!is.na(pedigree))  # outcome must be present\n\nsummary(pima_imp)\n```\n\n### 1. WRONG pipeline: impute using global mean (leakage)\n\nHere we:\n\n1. Compute the **global mean insulin** using all rows.\n2. Impute missing insulin values with this global mean.\n3. Then split into train/test.\n4. Fit `pedigree ~ age + insulin_imp` and evaluate MAE.\n\n```{r}\n# 1. Global mean (leaky: uses all data)\nmean_all_insulin <- mean(pima_imp$insulin, na.rm = TRUE)\nmean_all_insulin\n```\n\n```{r}\n# 2. Impute WHOLE dataset with global mean (before splitting)\npima_imp_wrong <- pima_imp %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_all_insulin, insulin)\n  )\n\nsummary(pima_imp_wrong$insulin_imp)\n```\n\n```{r}\n# 3. Train–test split AFTER imputation (still leaky)\nset.seed(123)\nsplit_wrong <- initial_split(pima_imp_wrong, prop = 0.7)\n\ntrain_wrong <- training(split_wrong)\ntest_wrong  <- testing(split_wrong)\n\nnrow(train_wrong); nrow(test_wrong)\n```\n\n```{r}\n# 4. Fit linear regression and compute MAE (WRONG)\nped_model <- linear_reg() %>%\n  set_engine(\"lm\")\n\nfit_wrong_imp <- ped_model %>%\n  fit(pedigree ~ age + insulin_imp, data = train_wrong)\n\ntidy(fit_wrong_imp)\n```\n\n```{r}\nresults_wrong_imp <- predict(fit_wrong_imp, new_data = test_wrong) %>%\n  bind_cols(test_wrong)\n\nmae_wrong_imp <- mae(\n  data     = results_wrong_imp,\n  truth    = pedigree,\n  estimate = .pred\n)\n\nmae_wrong_imp\n```\n\n---\n\n### 2. RIGHT pipeline: impute using training mean only (no leakage)\n\nNow we:\n\n1. Split the **original (unimputed)** data into train/test.\n2. Compute mean insulin **using training data only**.\n3. Impute train and test using this **training mean**.\n4. Fit the same model and compute MAE.\n\n```{r}\n# 1. Train–test split on RAW data\nset.seed(123)\nsplit_right <- initial_split(pima_imp, prop = 0.7)\n\ntrain_right <- training(split_right)\ntest_right  <- testing(split_right)\n\nnrow(train_right); nrow(test_right)\n```\n\n```{r}\n# 2. Training-only mean for insulin (correct)\nmean_tr_insulin <- mean(train_right$insulin, na.rm = TRUE)\nmean_tr_insulin\n```\n\n```{r}\n# 3. Impute train and test using TRAIN mean\ntrain_right_imp <- train_right %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_tr_insulin, insulin)\n  )\n\ntest_right_imp <- test_right %>%\n  mutate(\n    insulin_imp = ifelse(is.na(insulin), mean_tr_insulin, insulin)\n  )\n\nsummary(train_right_imp$insulin_imp)\nsummary(test_right_imp$insulin_imp)\n```\n\n```{r}\n# 4. Fit linear regression and compute MAE (RIGHT)\nfit_right_imp <- ped_model %>%\n  fit(pedigree ~ age + insulin_imp, data = train_right_imp)\n\ntidy(fit_right_imp)\n```\n\n```{r}\nresults_right_imp <- predict(fit_right_imp, new_data = test_right_imp) %>%\n  bind_cols(test_right_imp)\n\nmae_right_imp <- mae(\n  data     = results_right_imp,\n  truth    = pedigree,\n  estimate = .pred\n)\n\nmae_right_imp\n```\n\n---\n\n### 3. Compare MAE: imputation with vs without leakage\n\n```{r}\ntibble(\n  pipeline = c(\"WRONG: impute with global mean (leakage)\",\n               \"RIGHT: impute with training mean only\"),\n  MAE = c(mae_wrong_imp$.estimate,\n          mae_right_imp$.estimate)\n)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"python":{"version":"r-reticulate"},"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"pima_imputation_leakage.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","editor":"visual","theme":"cosmo","title":"Pima Imputation → Leak vs Leak-free (R)"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}